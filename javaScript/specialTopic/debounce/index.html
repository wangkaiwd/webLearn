<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>Document</title>
  <style>
    #container {
      width: 100%;
      height: 200px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 30px;
      color: #fff;
      background-color: #444;
    }
  </style>
</head>

<body>
  <div id="container">
    0
  </div>
  <script>
    const container = document.getElementById('container')
    let count = 1;
    const getUserAction = () => {
      container.innerHTML = count++
    }
    // 一些频繁触发的事件:
    //    1. window的resize,scroll
    //    2. mousedown、mousemove
    //    mousedown: 按下鼠标键时触发(这个事件会频繁触发吗？保持怀疑)
    // 解决方法：
    //   1. debounce 防抖
    //   2. throttle 节流

    //  防抖的原理： 要等你触发完事件n秒内不再触发事件，我才执行

    // 创建了全局变量
    // let timerId = null
    // const debounce = () => {
    //   timerId = setTimeout(() => {
    //     // getUserAction()
    //     cb()
    //   }, 1000)
    // }

    // 问题：1. 延迟时间不能写死  
    //      2. 定时器位置可以直接设置函数
    // const debounce = (cb) => {
    //   let timerId = null
    //   return () => {
    //     timerId = setTimeout(() => {
    //       cb()
    //     }, 2000)
    //   }
    // }

    const debounce = (cb, await = 2000) => {
      let timerId = null
      return () => { timerId = setTimeout(cb, await) }
    }
    // 当执行内容比较复杂或者需要进行ajax请求时，就会有卡顿效果产生
    container.addEventListener('mousemove', debounce(getUserAction))
  </script>
</body>

</html>
