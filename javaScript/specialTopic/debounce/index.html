<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>Document</title>
  <style>
    #container {
      width: 100%;
      height: 200px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 30px;
      color: #fff;
      background-color: #444;
    }
  </style>
</head>

<body>
  <div id="container">
    0
  </div>
  <button id="button">cancel debounce</button>
  <script>
    const container = document.getElementById('container')
    const button = document.getElementById('button')
    let count = 1;
    const getUserAction = (e) => {
      console.log('e', e)
      container.innerHTML = count++
    }
    // 传入immediate，可以让函数立即执行，之后等await ms后再次立即执行
    // 添加取消功能
    const debounce = (cb, await = 2000, immediate) => {
      let timerId = null
      const debounced = (e) => {
        // 传入一个错误的ID给clearTimeout()不会有任何影响；也不会跑出异常
        clearTimeout(timerId) // 只是取消了当前timerId对应的逻辑(函数)的执行
        if (immediate) {
          // 第一次立即执行，之后会等timerId再置为null的时候再执行
          if (!timerId) cb(e)

          timerId = setTimeout(() => timerId = null, await)
        } else {
          timerId = setTimeout(() => cb(e), await)
        }
      }
      debounced.cancel = () => {
        clearTimeout(timerId)
        timerId = null // 去报回调立即执行
      }
      return debounced
    }
    const debounced = debounce(getUserAction, 10000, true)
    // 当执行内容比较复杂或者需要进行ajax请求时，就会有卡顿效果产生
    container.addEventListener('mousemove', debounced)
    button.addEventListener('click', debounced.cancel)
  </script>
</body>

</html>